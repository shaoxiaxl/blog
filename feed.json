{
    "version": "https://jsonfeed.org/version/1",
    "title": "少侠的记事本",
    "description": "",
    "home_page_url": "https://shaoxiaxl.github.io/blog",
    "feed_url": "https://shaoxiaxl.github.io/blog/feed.json",
    "user_comment": "",
    "author": {
        "name": "ShaoXia"
    },
    "items": [
        {
            "id": "https://shaoxiaxl.github.io/blog/css-chang-yong-shu-xing.html",
            "url": "https://shaoxiaxl.github.io/blog/css-chang-yong-shu-xing.html",
            "title": "CSS常用属性",
            "summary": "1. 选择器元素类型h1 {}类 类型.class {}ID选择器#id {}指向特定元素的类或者IDh1.class {}h1#id {}标签选择器a[title] {} 或者特定值a[herf=&#39;http://baidu.con&#39;] {}运算符article &gt; p {}2. 布局displayblockinlinegridflexinline-blockpositiontable关注table-layout:fixedfloat其他的周围内容会在这个被浮动的元素周围环绕3. 调整大小 min- max-width:100%图片拉伸到与容器相同的宽度max-width:100% 不会大于原始尺寸object-fit:cover 缩小图像，维持了图像的比例object-fit:contain 图像将缩放到足以放到盒子里的大小4. 溢出的内容overflowvisiblehiddenscrollautiooverflow-y:scroll y轴方向滚动overflow-x: x轴方向的滚动5. 背景background-colorbackground-imager:url()background-repeat 是否平铺图片 no-repeatbackground-sizecover 浏览器将使图像足够大，使他完全覆盖了盒子区。contain 浏览器将使图像的大小适合盒子内background-postion 背景定位background-postion: top 10% right 10pxbackground-attachment 背景页面滚动scroll 元素的背景在页面滚动时候滚动fixed 使元素的背景固定在视图端口上6. 边框borderborder: 1px solid blackborder-radius 边框圆角7.伪类和伪元素:frist-child用户行为的伪类:hover:focus伪元素::frist-line::before和::after8. css继承inherit 开启继承initial 设置属性值和浏览器默认样式相同。unset&hellip;",
            "content_html": "<h2 id=\"1-选择器\">1. 选择器</h2>\n<ul>\n<li>元素类型\n<code>h1 {}</code></li>\n<li>类 类型\n<code>.class {}</code></li>\n<li>ID选择器\n<code>#id {}</code></li>\n<li>指向特定元素的类或者ID\n<code>h1.class {}\nh1#id {}</code></li>\n<li>标签选择器\n<code>a[title] {}</code> 或者特定值<code>a[herf=&#39;http://baidu.con&#39;] {}</code></li>\n<li>运算符\n<code>article &gt; p {}</code></li>\n</ul>\n<h2 id=\"2-布局\">2. 布局</h2>\n<ul>\n<li><h3 id=\"display\">display</h3>\n<ul>\n<li>block</li>\n<li>inline</li>\n<li>grid</li>\n<li>flex</li>\n<li>inline-block</li>\n</ul>\n</li>\n<li><h3 id=\"position\">position</h3>\n</li>\n<li><h3 id=\"table\">table</h3>\n<ul>\n<li>关注<code>table-layout:fixed</code></li>\n</ul>\n</li>\n<li><h3 id=\"float\">float</h3>\n<ul>\n<li>其他的周围内容会在这个被浮动的元素周围环绕</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-调整大小-min--max-\">3. 调整大小 min- max-</h2>\n<ul>\n<li><h3 id=\"width100图片拉伸到与容器相同的宽度\"><code>width:100%</code>图片拉伸到与容器相同的宽度</h3>\n</li>\n<li><h3 id=\"max-width100-不会大于原始尺寸\"><code>max-width:100%</code> 不会大于原始尺寸</h3>\n</li>\n<li><h3 id=\"object-fitcover-缩小图像，维持了图像的比例\"><code>object-fit:cover</code> 缩小图像，维持了图像的比例</h3>\n</li>\n<li><h3 id=\"object-fitcontain-图像将缩放到足以放到盒子里的大小\"><code>object-fit:contain</code> 图像将缩放到足以放到盒子里的大小</h3>\n</li>\n</ul>\n<h2 id=\"4-溢出的内容\">4. 溢出的内容</h2>\n<ul>\n<li><h3 id=\"overflow\">overflow</h3>\n<ul>\n<li>visible</li>\n<li>hidden</li>\n<li>scroll</li>\n<li>autio</li>\n</ul>\n</li>\n<li><h3 id=\"overflow-yscroll-y轴方向滚动\">overflow-y:scroll y轴方向滚动</h3>\n</li>\n<li><h3 id=\"overflow-x-x轴方向的滚动\">overflow-x: x轴方向的滚动</h3>\n</li>\n</ul>\n<h2 id=\"5-背景\">5. 背景</h2>\n<ul>\n<li><h3 id=\"background-color\">background-color</h3>\n</li>\n<li><h3 id=\"background-imagerurl\">background-imager:url()</h3>\n</li>\n<li><h3 id=\"background-repeat-是否平铺图片-no-repeat\">background-repeat 是否平铺图片 no-repeat</h3>\n</li>\n<li><h3 id=\"background-size\">background-size</h3>\n<ul>\n<li>cover 浏览器将使图像足够大，使他完全覆盖了盒子区。</li>\n<li>contain 浏览器将使图像的大小适合盒子内</li>\n</ul>\n</li>\n<li><h3 id=\"background-postion-背景定位\">background-postion 背景定位</h3>\n<ul>\n<li><code>background-postion: top 10% right 10px</code></li>\n</ul>\n</li>\n<li><h3 id=\"background-attachment-背景页面滚动\">background-attachment 背景页面滚动</h3>\n<ul>\n<li>scroll 元素的背景在页面滚动时候滚动</li>\n<li>fixed 使元素的背景固定在视图端口上</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-边框\">6. 边框</h2>\n<ul>\n<li><h3 id=\"border\">border</h3>\n<ul>\n<li><code>border: 1px solid black</code></li>\n</ul>\n</li>\n<li><h3 id=\"border-radius-边框圆角\">border-radius 边框圆角</h3>\n</li>\n</ul>\n<h2 id=\"7伪类和伪元素\">7.伪类和伪元素</h2>\n<ul>\n<li>:frist-child</li>\n<li>用户行为的伪类<ul>\n<li>:hover</li>\n<li>:focus</li>\n</ul>\n</li>\n<li>伪元素<ul>\n<li>::frist-line</li>\n</ul>\n</li>\n<li>::before和::after</li>\n</ul>\n<h2 id=\"8-css继承\">8. css继承</h2>\n<ul>\n<li>inherit 开启继承</li>\n<li>initial 设置属性值和浏览器默认样式相同。</li>\n<li>unset 将属性重置为自然值，如果是自然继承那么就是inherit,否则是initial</li>\n<li>!important 优先</li>\n<li>内联&gt; id选择器&gt; 类选择器&gt; 元素选择器伪元素选择器</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference\">参考大全</a></p>\n",
            "author": {
                "name": "ShaoXia"
            },
            "tags": [
            ],
            "date_published": "2020-11-19T22:48:46+08:00",
            "date_modified": "2020-11-20T22:00:11+08:00"
        },
        {
            "id": "https://shaoxiaxl.github.io/blog/ri-chang-yong-de-lian-jie.html",
            "url": "https://shaoxiaxl.github.io/blog/ri-chang-yong-de-lian-jie.html",
            "title": "日常用的链接",
            "summary": "优秀的产品Product Hunt每天都会发布最好的新产品。 ",
            "content_html": "<p><a href=\"https://www.producthunt.com/\">优秀的产品</a>Product Hunt每天都会发布最好的新产品。</p>\n<p> </p>",
            "author": {
                "name": "ShaoXia"
            },
            "tags": [
            ],
            "date_published": "2020-11-10T14:34:16+08:00",
            "date_modified": "2020-11-10T14:34:16+08:00"
        },
        {
            "id": "https://shaoxiaxl.github.io/blog/ubuntu-xi-tong-you-hua.html",
            "url": "https://shaoxiaxl.github.io/blog/ubuntu-xi-tong-you-hua.html",
            "title": "ubuntu系统优化!",
            "summary": "完整的/etc/sysctl.conf修改添加内容如下：在/etc/sysctl.conf中添加如下内容 # 网络参数优化开始net.ipv4.tcp_max_syn_backlog = 65536net.core.netdev_max_backlog = 32768net.core.somaxconn = 32768net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.tcp_timestamps = 0net.ipv4.tcp_synack_retries = 2net.ipv4.tcp_syn_retries = 2net.ipv4.tcp_tw_recycle = 1#net.ipv4.tcp_tw_len = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_mem = 94500000 915000000 927000000net.ipv4.tcp_max_orphans = 3276800#net.ipv4.tcp_fin_timeout = 30#net.ipv4.tcp_keepalive_time = 120net.ipv4.ip_local_port_range = 1024 65535#网络参数优化结束#系统共享内存大小优化开始kernel.shmmax = 134217728#系统共享内存大小优化结束#添加内容结束修改完成后运行以下命令使参数生效 /sbin/sysctl&hellip;",
            "content_html": "<p>完整的/etc/sysctl.conf修改添加内容如下：\n在/etc/sysctl.conf中添加如下内容</p>\n<pre><code class=\"language-shell\"># 网络参数优化开始\nnet.ipv4.tcp_max_syn_backlog = 65536\nnet.core.netdev_max_backlog =  32768\nnet.core.somaxconn = 32768\n\nnet.core.wmem_default = 8388608\nnet.core.rmem_default = 8388608\nnet.core.rmem_max = 16777216\nnet.core.wmem_max = 16777216\n\nnet.ipv4.tcp_timestamps = 0\nnet.ipv4.tcp_synack_retries = 2\nnet.ipv4.tcp_syn_retries = 2\n\nnet.ipv4.tcp_tw_recycle = 1\n#net.ipv4.tcp_tw_len = 1\nnet.ipv4.tcp_tw_reuse = 1\n\nnet.ipv4.tcp_mem = 94500000 915000000 927000000\nnet.ipv4.tcp_max_orphans = 3276800\n\n#net.ipv4.tcp_fin_timeout = 30\n#net.ipv4.tcp_keepalive_time = 120\nnet.ipv4.ip_local_port_range = 1024  65535\n#网络参数优化结束\n#系统共享内存大小优化开始\nkernel.shmmax = 134217728\n#系统共享内存大小优化结束\n#添加内容结束</code></pre>\n<p>修改完成后运行以下命令使参数生效</p>\n<pre><code>/sbin/sysctl -p</code></pre><p>以上，如有不足，欢迎大家指正和追加，谢谢！</p>\n",
            "author": {
                "name": "ShaoXia"
            },
            "tags": [
                   "优化"
            ],
            "date_published": "2018-11-20T21:17:00+08:00",
            "date_modified": "2020-11-20T22:20:24+08:00"
        },
        {
            "id": "https://shaoxiaxl.github.io/blog/day1macd-hekdj-ce-lue.html",
            "url": "https://shaoxiaxl.github.io/blog/day1macd-hekdj-ce-lue.html",
            "title": "Day1,MACD和KDJ策略",
            "summary": "思路毫无疑问很多人分析市场都是从MACD和KDJ开始的，MACD是一种趋势分析指标。KDJ的中文叫随机指标，是技术分析中的一种动量分析方法，采用超买和超卖的概念。 MACD的输入参数有两个: KDJKDJ 的输入参数：KDJ 交易信号当价格与随机指标发生牛势背离（即价格下跌而随机指标指向上方），而%K线与%D线在超卖区（高于80%或低于20%）发生交叉，便是买入信号；反之则是卖出信号。%K线与%D线的简单交叉经常发生，很多时候并不可靠。投资者多在%D线筑顶或筑底后，等待%K线出现急剧的逆转并与%D线交叉。当市场波动性较大时，也可使用加权移动平均来定义%D线，以平整价格短时内大幅波动对指标产生的影响。",
            "content_html": "<p>思路\n毫无疑问很多人分析市场都是从MACD和KDJ开始的，MACD是一种趋势分析指标。KDJ的中文叫随机指标，是技术分析中的一种动量分析方法，采用超买和超卖的概念。</p>\n<p>MACD的输入参数有两个:</p>\n<ol>\n<li>EMA(12)；</li>\n<li>EMA(26)；\nMACD三种交易讯号：</li>\n<li>差离值（DIF值）与讯号线（DEM值，又称MACD值）相交；当差离值（DIF）从下而上穿过讯号线（DEM），为买进讯号；相反若从上而下穿越，为卖出讯号。买卖讯号可能出现频繁，需要配合其他指标（如：RSI、KD）一同分析。</li>\n<li>差离值与零轴相交；差离值由下而上穿过零轴代表市场气氛利好股价，相反由上而下则代表利淡股价。差离值与讯号线均在零轴上方时，被称为多头市场，反之，则被称为空头市场。</li>\n<li>股价与差离值的背离。当股价创新低，但MACD并没有相应创新低（牛市背离），视为利好（利多）讯息，股价跌势或将完结。相反，若股价创新高，但MACD并没有相应创新高（熊市背离），视为利淡（利空）讯息。同样地，若股价与棒形图不配合，也可作类似结论。\n总而言之MACD是一种中长线的研判指标。当股市强烈震荡或股价变化巨大时，可能会给出错误的信号。所以在决定股票操作时，应该谨慎参考其他指标，以及市场状况，不能完全信任差离值的单一研判，避免造成损失。</li>\n</ol>\n<p>KDJ\nKDJ 的输入参数：\nKDJ 交易信号\n当价格与随机指标发生牛势背离（即价格下跌而随机指标指向上方），而%K线与%D线在超卖区（高于80%或低于20%）发生交叉，便是买入信号；反之则是卖出信号。%K线与%D线的简单交叉经常发生，很多时候并不可靠。投资者多在%D线筑顶或筑底后，等待%K线出现急剧的逆转并与%D线交叉。当市场波动性较大时，也可使用加权移动平均来定义%D线，以平整价格短时内大幅波动对指标产生的影响。</p>\n",
            "author": {
                "name": "ShaoXia"
            },
            "tags": [
                   "财经"
            ],
            "date_published": "2018-06-20T23:28:00+08:00",
            "date_modified": "2020-11-20T23:31:48+08:00"
        },
        {
            "id": "https://shaoxiaxl.github.io/blog/fen-hua-du-de-qu-shi-ce-lue-yong-yu-zhi-shu-de-ce-lue.html",
            "url": "https://shaoxiaxl.github.io/blog/fen-hua-du-de-qu-shi-ce-lue-yong-yu-zhi-shu-de-ce-lue.html",
            "title": "分化度的趋势策略，用于指数的策略",
            "summary": "分化度简介在固定时间截面下，给定一个市场指数及其成分股的区间收益，则所有成份股区间收益率的分化程度即为股票分化度，用收益率的标准差表示。第 t 期的股票分化度 RD， 追涨杀跌，有趋势才有收益，没趋势时候，可能会损失。趋势确定后买入，趋势破灭后卖出，有滞后性，赶不及。常用的指标是均线和通道突破，均线交易多，胜率低。通道交易少，胜率高，持股久。 当较小的股票分化度变化，引起了同方向较大的指数涨跌幅变化时，趋势结束的概率会增加。顺着这个思路，我们以 4 周动量策略为基础，构建基于股票分化度的指数趋势策略。如果本周相对上周指数涨跌幅的变化，大于 N 倍的股票分化度变化，则判断市场出现了特殊的状况，空仓观望；否则为正常的市场状况，按照正常的 4 周动量信号行动。即，空仓时，趋势策略出现买入信号，最近某个周期的指数涨幅，大于指数成分股票的分化度的N倍，则判断市场出现特殊状况，空仓。否则为正常买入。持仓时，某个周期的指数涨幅，大于指数成分股票的分化度的N倍，则判断市场出现特殊状况，卖出。卖出信号正常卖出。 参考",
            "content_html": "<h3 id=\"分化度简介\">分化度简介</h3>\n<p>在固定时间截面下，给定一个市场指数及其成分股的区间收益，则所有成份股\n区间收益率的分化程度即为股票分化度，用收益率的标准差表示。第 t 期的股\n票分化度 RD，</p>\n<h3 id=\"趋势策略简介\">趋势策略简介</h3>\n<p>追涨杀跌，有趋势才有收益，没趋势时候，可能会损失。趋势确定后买入，趋势破灭后卖出，有滞后性，赶不及。\n常用的指标是均线和通道突破，均线交易多，胜率低。通道交易少，胜率高，持股久。</p>\n<h3 id=\"分化趋势策略\">分化趋势策略</h3>\n<p>当较小的股票分化度变化，引起了同方向较大的指数涨跌幅变化时，趋势结束的概率会增加。顺着这\n个思路，我们以 4 周动量策略为基础，构建基于股票分化度的指数趋势策略。\n如果本周相对上周指数涨跌幅的变化，大于 N 倍的股票分化度变化，则判断市\n场出现了特殊的状况，空仓观望；否则为正常的市场状况，按照正常的 4 周动\n量信号行动。\n即，空仓时，趋势策略出现买入信号，最近某个周期的指数涨幅，大于指数成分股票的分化度的N倍，则判断市场\n出现特殊状况，空仓。否则为正常买入。\n持仓时，某个周期的指数涨幅，大于指数成分股票的分化度的N倍，则判断市场\n出现特殊状况，卖出。卖出信号正常卖出。</p>\n<p><a href=\"http://pg.jrj.com.cn/acc/Res/CN_RES/INVEST/2017/11/23/10ed4c24-f80f-45d6-bded-af7f6b131b8e.pdf\">参考</a></p>\n",
            "author": {
                "name": "ShaoXia"
            },
            "tags": [
            ],
            "date_published": "2018-05-20T10:26:00+08:00",
            "date_modified": "2020-11-20T23:30:04+08:00"
        },
        {
            "id": "https://shaoxiaxl.github.io/blog/shi-yongpython-ti-huanwindows-wen-jian-tu-biao.html",
            "url": "https://shaoxiaxl.github.io/blog/shi-yongpython-ti-huanwindows-wen-jian-tu-biao.html",
            "title": "使用python替换windows文件图标",
            "summary": "# encoding: utf-8from win32com.shell import shell, shellconimport winerrorimport urllibimport subprocessdriveRoots = []currentFolderUri = NonesyncStatuses = Nonedef nxlog(msg): #记录调试日志 logFile = open(&quot;C:\\\\Users\\\\Administrator\\\\driveOverlay.log&quot;, &quot;a&quot;) logFile.write(msg + &quot;\\n&quot;) logFile.close()class IconOverlay: #可以自动生成 _reg_clsid_ = &#39;{B4123171-F6D6-4FAD-9402-8F6B04E439C7}&#39; _reg_progid_ = &#39;NuxeoDrive.PythonOverlayHandler&#39; _reg_desc_ = &#39;Icon Overlay Handler for Nuxeo Drive&#39; _public_methods_ = [&#39;GetOverlayInfo&#39;,&hellip;",
            "content_html": "<pre><code># encoding: utf-8\nfrom win32com.shell import shell, shellcon\nimport winerror\nimport urllib\nimport subprocess\ndriveRoots = []\ncurrentFolderUri = None\nsyncStatuses = None\ndef nxlog(msg):\n    #记录调试日志\n    logFile = open(&quot;C:\\\\Users\\\\Administrator\\\\driveOverlay.log&quot;, &quot;a&quot;)\n    logFile.write(msg + &quot;\\n&quot;)\n    logFile.close()\nclass IconOverlay:\n    #可以自动生成\n    _reg_clsid_ = &#39;{B4123171-F6D6-4FAD-9402-8F6B04E439C7}&#39;\n    _reg_progid_ = &#39;NuxeoDrive.PythonOverlayHandler&#39;\n    _reg_desc_ = &#39;Icon Overlay Handler for Nuxeo Drive&#39;\n    _public_methods_ = [&#39;GetOverlayInfo&#39;, &#39;GetPriority&#39;, &#39;IsMemberOf&#39;]\n    _com_interfaces_ = [shell.IID_IShellIconOverlayIdentifier]\n    def __init__(self):\n        nxlog(&quot;Starting&quot;)\n    def GetOverlayInfo(self):\n        nxlog(&quot;return Normal icon&quot;)\n        return (r&#39;C:\\sync\\logo.ico&#39;, 0, shellcon.ISIOI_ICONFILE)\n    def GetPriority(self):\n        return 50\n    #判断方法\n    def IsMemberOf(self, fname, attributes):\n        nxlog(&quot;calling isMember on &quot; + fname)\n        if (&quot;nuxeo&quot; in fname):\n            if (&quot;finan&quot; in fname):\n                return winerror.S_FALSE\n            else:\n                nxlog(&quot;return ok for synced&quot;)\n                return winerror.S_OK\n        return winerror.S_FALSE\nclass PendingIconOverlay:\n    _reg_clsid_ = &#39;{BE8CEBD1-5AB8-403F-9984-F34251A1705C}&#39;\n    _reg_progid_ = &#39;NuxeoDrive.PythonPendingOverlayHandler&#39;\n    _reg_desc_ = &#39;Icon Overlay Handler for Nuxeo Drive Pending files&#39;\n    _public_methods_ = [&#39;GetOverlayInfo&#39;, &#39;GetPriority&#39;, &#39;IsMemberOf&#39;]\n    _com_interfaces_ = [shell.IID_IShellIconOverlayIdentifier]\n    def __init__(self):\n        nxlog(&quot;Starting&quot;)\n    def GetOverlayInfo(self):\n        nxlog(&quot;return Modified icon&quot;)\n        return (r&#39;C:\\sync\\logo.ico&#39;, 0, shellcon.ISIOI_ICONFILE)\n    def GetPriority(self):\n        return 50\n    def IsMemberOf(self, fname, attributes):\n        nxlog(&quot;calling isMember on &quot; + fname)\n        if (&quot;nuxeo&quot; in fname):\n            if (&quot;finan&quot; in fname):\n                nxlog(&quot;return ok for pending&quot;)\n                return winerror.S_OK\n            else:\n                return winerror.S_FALSE\n        return winerror.S_FALSE\nif __name__ == &#39;__main__&#39;:\n    import win32api\n    import win32con\n    import win32com.server.register\n    win32com.server.register.UseCommandLine(IconOverlay)\n    keyname = r&#39;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers\\  NuxeoDriveOverlay&#39;\n    key = win32api.RegCreateKey(win32con.HKEY_LOCAL_MACHINE, keyname)\n    win32api.RegSetValue(key, None, win32con.REG_SZ, IconOverlay._reg_clsid_)\n    win32com.server.register.UseCommandLine(PendingIconOverlay)\n    keyname = r&#39;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers\\  NuxeoDrivePendingOverlay&#39;\n    key = win32api.RegCreateKey(win32con.HKEY_LOCAL_MACHINE, keyname)\n    win32api.RegSetValue(key, None, win32con.REG_SZ,\nPendingIconOverlay._reg_clsid_)</code></pre>",
            "author": {
                "name": "ShaoXia"
            },
            "tags": [
            ],
            "date_published": "2017-11-13T23:26:00+08:00",
            "date_modified": "2020-11-20T23:26:51+08:00"
        },
        {
            "id": "https://shaoxiaxl.github.io/blog/python-zhuang-shi-qi.html",
            "url": "https://shaoxiaxl.github.io/blog/python-zhuang-shi-qi.html",
            "title": "python装饰器",
            "summary": "import time def function_performance_statistics(trace_this=True): if trace_this: def performace_statistics_delegate(func): def counter(*args, **kwargs): start = time.clock() func(*args, **kwargs) end =time.clock() print &#39;used time: %d&#39; % (end - start, ) return counter else: def performace_statistics_delegate(func): return func return performace_statistics_delegate @function_performance_statistics(True) def add(x, y): time.sleep(3) print &#39;add result: %d&#39;&hellip;",
            "content_html": "<pre><code>import time  \n\ndef function_performance_statistics(trace_this=True):  \n    if trace_this:  \n       def performace_statistics_delegate(func):  \n            def counter(*args, **kwargs):  \n                start = time.clock()  \n                func(*args, **kwargs)  \n                end =time.clock()  \n                print &#39;used time: %d&#39; % (end - start, )  \n            return counter  \n    else:  \n       def performace_statistics_delegate(func):  \n            return func  \n    return performace_statistics_delegate  \n\n@function_performance_statistics(True)  \ndef add(x, y):  \n    time.sleep(3)  \n    print &#39;add result: %d&#39; % (x + y,)  \n\n@function_performance_statistics(False)  \ndef mul(x, y=1):  \n    print &#39;mul result: %d&#39; % (x * y,)  \n\nadd(1, 1)  \nmul(10)</code></pre>",
            "author": {
                "name": "ShaoXia"
            },
            "tags": [
            ],
            "date_published": "2017-08-22T20:08:00+08:00",
            "date_modified": "2020-11-20T23:08:52+08:00"
        },
        {
            "id": "https://shaoxiaxl.github.io/blog/shi-yongopencv-jia-jian-ji-shi-pin.html",
            "url": "https://shaoxiaxl.github.io/blog/shi-yongopencv-jia-jian-ji-shi-pin.html",
            "title": "使用opencv夹剪辑视频",
            "summary": "opencv介绍安装opencv2支持python2.x版本 因为opencv依赖numpy所以我们要先安装numpy 安装完成后，打开IDE确保安装成功 C:\\libpython&gt;python.exePython 2.7.13 (v2.7.13:a06454b1afa1, Dec 17 2016, 20:53:40) [MSC v.1500 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import numpy&gt;&gt;&gt;下载OpenCV安装包，安装后解压 打开解压目录 opencv/build/python/2.7 复制cv2.pyd 到你python的Python27/lib/site-packeges目录下 打开IDE确保安装正常 &gt;&gt;&gt; print cv2.__version__&#39;2.4.13.3&#39;官方教程 按照他官方的教程到这一步导入cv2包没有问题，就算安装成功了。但是在实际使用中打开视频文件的时候总是失败，网上搜同样的问题一大把，不清楚到底是bug，还是电脑环境问题（怀疑的问题系统环境变量path）。 stackoverflow上讨论和解决方法 我的解决方法是把 J:\\opencv\\opencv\\sources\\3rdparty\\ffmpeg目录下的opencv_ffmpeg_64.dll文件复制到我python目录下并改名为opencv_ffmpeg{opencv版本号}_64.dll我的是opencv_ffmpeg2413_64.dll 使用打开一个视频文件#打开视频文件 cap = cv2.VideoCapture(in_path) if False&hellip;",
            "content_html": "<h3 id=\"opencv介绍\">opencv介绍</h3>\n<h4 id=\"安装\">安装</h4>\n<p>opencv2支持python2.x版本</p>\n<ol>\n<li><p>因为opencv依赖numpy所以我们要先安装numpy  </p>\n<ul>\n<li>可以这样安装sudo pip install numpy</li>\n<li>或者下载安装包安装 numpy下载</li>\n</ul>\n</li>\n<li><p>安装完成后，打开IDE确保安装成功</p>\n<pre><code>C:\\libpython&gt;python.exe\nPython 2.7.13 (v2.7.13:a06454b1afa1, Dec 17 2016, 20:53:40) [MSC v.1500 64 bit (AMD64)] on win32\nType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.\n&gt;&gt;&gt; import numpy\n&gt;&gt;&gt;</code></pre></li>\n<li><p>下载OpenCV安装包，安装后解压</p>\n</li>\n<li><p>打开解压目录 opencv/build/python/2.7</p>\n</li>\n<li><p>复制cv2.pyd 到你python的Python27/lib/site-packeges目录下</p>\n</li>\n<li><p>打开IDE确保安装正常</p>\n<pre><code class=\"language-&gt;&gt;&gt;\">&gt;&gt;&gt; print cv2.__version__\n&#39;2.4.13.3&#39;</code></pre>\n<p><a href=\"https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_setup/py_setup_in_windows/py_setup_in_windows.html#install-opencv-python-in-windows\">官方教程</a></p>\n</li>\n</ol>\n<p>按照他官方的教程到这一步导入cv2包没有问题，就算安装成功了。但是在实际使用中打开视频文件的时候总是失败，网上搜同样的问题一大把，不清楚到底是bug，还是电脑环境问题（怀疑的问题系统环境变量path）。</p>\n<p><a href=\"https://stackoverflow.com/questions/11699298/opencv-2-4-videocapture-not-working-on-windows\">stackoverflow上讨论和解决方法</a></p>\n<p>我的解决方法是把 <code>J:\\opencv\\opencv\\sources\\3rdparty\\ffmpeg</code>目录下的<code>opencv_ffmpeg_64.dll</code>文件复制到我python目录下并改名为<code>opencv_ffmpeg{opencv版本号}_64.dll</code>我的是<code>opencv_ffmpeg2413_64.dll</code></p>\n<p>使用\n打开一个视频文件\n#打开视频文件</p>\n<pre><code>cap = cv2.VideoCapture(in_path)   \nif False == cap.isOpened():  #判断打开是否成功\n    print(&quot;error&quot;)\nelse:\n    print(&quot;ok&quot;)</code></pre><p>读取视频\n获取解码并返回视频下一帧，失败返回false。\n<code>ret, frame = cap.read()</code>\n获取视频属性\n可以用cap.get(propId)方法获得视频的属性，propId的范围为0-18，每个数代表视频的一个属性，官方说明看这里VideoCapture::get。</p>\n<p>常用参数</p>\n<ul>\n<li>propId |    属性</li>\n<li>0    | 当前文件位置时间</li>\n<li>1    |下一帧</li>\n<li>3    | 宽度</li>\n<li>4|    高度</li>\n<li>5    | 帧速</li>\n<li>6    | 视频编码格式</li>\n<li>7    | 文件总帧数\n还有一种方法来获取视频参数</li>\n</ul>\n<p>帧速\n<code>fps = cap.get(cv2.cv.CV_CAP_PROP_FPS)</code>\n#宽高<br><code>size = (int(cap.get(cv2.cv.CV_CAP_PROP_FRAME_WIDTH)),   \n        int(cap.get(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT)))</code>\n设置视频属性\n可以用<code>cap.set(propId, value)</code>方法设置视频的属性<code>VideoCapture::set</code></p>\n<ul>\n<li><p>propId |    属性</p>\n</li>\n<li><p>0 |    视频文件的当前位置，以毫秒为单位。</p>\n</li>\n<li><p>1 |    下一帧解码/捕获帧的索引</p>\n</li>\n<li><p>2 |    视频文件的相对位置：0 - 开始，1 - 结束。</p>\n</li>\n<li><p>3 |    视频流的宽度</p>\n</li>\n<li><p>4 |    视频流的高度</p>\n</li>\n<li><p>5 |    帧速</p>\n</li>\n<li><p>6 |    编解码器的4个字符代码。</p>\n</li>\n<li><p>7 |    视频文件中的帧数\n使用opencv剪辑视频</p>\n<pre><code>def cut_video(in_path, out_path, start, end):\n  cap = cv2.VideoCapture(in_path)\n  fps = cap.get(cv2.cv.CV_CAP_PROP_FPS)\n  size = (int(cap.get(cv2.cv.CV_CAP_PROP_FRAME_WIDTH)),   \n          int(cap.get(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT)))\n  fourcc = cv2.cv.CV_FOURCC(*&#39;XVID&#39;)\n  out = cv2.VideoWriter(out_path, fourcc, fps, size)\n\n  for index in range(start,end):\n      cap.set(1, index)\n      ret, frame = cap.read()\n      cv2.waitKey(1000/int(fps))\n      cv2.imshow(&quot;video&quot;, frame)#边查看\n      out.write(frame)\n  cap.release() #释放\n  out.release()</code></pre></li>\n</ul>\n",
            "author": {
                "name": "ShaoXia"
            },
            "tags": [
            ],
            "date_published": "2017-08-17T21:02:00+08:00",
            "date_modified": "2020-11-20T23:25:40+08:00"
        },
        {
            "id": "https://shaoxiaxl.github.io/blog/config-wen-jian-de-you-ya-xie-fa.html",
            "url": "https://shaoxiaxl.github.io/blog/config-wen-jian-de-you-ya-xie-fa.html",
            "title": "config文件的优雅写法",
            "summary": "问题:写程序经常要用到配置文件，在python中配置文件可以很简单，直接建一个py文件，然后 config.py a = &quot;123&quot;b = &quot;456&quot;解决思路:这样写简单实用，但是不够通用，别人要来看的时候容易懵。要别人也容易懂一般写成ini 或者yml文件容易读一点，要读写yml要装第三方包，所以我用ini文件当配置文件，需要用到自带的configparser模块。 实现:配置文件目录.├── config.ini└── __init__.py__init__.py 适用python3 #!/usr/bin/env python# encoding: utf-8import configparserimport osconfig_env = os.getenv(&#39;DATA_CONFIG&#39;, &#39;config.ini&#39;)#DATA_CONFIG环境变量配置文件名字config = configparser.ConfigParser()config.read(os.path.join(os.path.dirname(__file__), config_env))#当前目录下适用python2 #!/usr/bin/env python# encoding: utf-8import ConfigParserimport osconfig_env = os.getenv(&#39;DATAPOINT_CONFIG&#39;, &#39;config.ini&#39;)config1 = ConfigParser.ConfigParser()config1.read(os.path.join(os.path.dirname(__file__), config_env))config = {}for k1 in config1.sections(): config[k1] = {} for&hellip;",
            "content_html": "<p>问题:\n写程序经常要用到配置文件，在python中配置文件可以很简单，直接建一个py文件，然后</p>\n<p><code>config.py</code></p>\n<pre><code>a = &quot;123&quot;\nb = &quot;456&quot;</code></pre><p>解决思路:\n这样写简单实用，但是不够通用，别人要来看的时候容易懵。\n要别人也容易懂一般写成ini 或者yml文件容易读一点，要读写yml要装第三方包，\n所以我用ini文件当配置文件，需要用到自带的configparser模块。</p>\n<p>实现:\n配置文件目录\n<code>.\n├── config.ini\n└── __init__.py\n__init__.py</code></p>\n<p>适用python3</p>\n<pre><code>#!/usr/bin/env python\n# encoding: utf-8\nimport configparser\nimport os\nconfig_env = os.getenv(&#39;DATA_CONFIG&#39;, &#39;config.ini&#39;)#DATA_CONFIG环境变量配置文件名字\nconfig = configparser.ConfigParser()\nconfig.read(os.path.join(os.path.dirname(__file__), config_env))#当前目录下</code></pre><p>适用python2</p>\n<pre><code>#!/usr/bin/env python\n# encoding: utf-8\nimport ConfigParser\nimport os\nconfig_env = os.getenv(&#39;DATAPOINT_CONFIG&#39;, &#39;config.ini&#39;)\nconfig1 = ConfigParser.ConfigParser()\nconfig1.read(os.path.join(os.path.dirname(__file__), config_env))\nconfig = {}\nfor k1 in config1.sections():\n   config[k1] = {}\n   for k2 in config1.options(k1):\n       config[k1][k2.upper()] = config1.get(k1, k2)</code></pre><p>config.ini</p>\n<pre><code>[APP]\nDEBUG=true\nPORT=8020\n[DATABASE]\nURL=127.0.0.1:7474\nENDPOINT=http://127.0.0.1:7474/db\nUSERNAME=root\nPASSWORD=root</code></pre><p>使用</p>\n<pre><code>from config import config\nurl = config[&#39;DATABASE&#39;][&#39;URL&#39;]\nusername = config[&#39;DATABASE&#39;][&#39;USERNAME&#39;]\npassword = config[&#39;DATABASE&#39;][&#39;PASSWORD&#39;]</code></pre>",
            "author": {
                "name": "ShaoXia"
            },
            "tags": [
            ],
            "date_published": "2017-08-14T17:09:00+08:00",
            "date_modified": "2020-11-20T23:11:57+08:00"
        },
        {
            "id": "https://shaoxiaxl.github.io/blog/yonggdb-diao-shipython.html",
            "url": "https://shaoxiaxl.github.io/blog/yonggdb-diao-shipython.html",
            "title": "用gdb调试python!",
            "summary": "###用gdb调试python! 1，安装 apt-get install gdbgdb (GDB) 7.0以上才支持sudo apt-get install gdb python2.7-dbg2,常用命令 py-listpy-up and py-downpy-btpy-printpy-localsinfo threadsthread apply all py-btfinishcontinuer",
            "content_html": "<p>###用gdb调试python!</p>\n<p>1，安装</p>\n<pre><code>apt-get install gdb\ngdb (GDB) 7.0以上才支持\nsudo apt-get install gdb python2.7-dbg</code></pre><p>2,常用命令</p>\n<pre><code>py-list\npy-up and py-down\npy-bt\npy-print\npy-locals\ninfo threads\nthread apply all py-bt\nfinish\ncontinue\nr</code></pre>",
            "author": {
                "name": "ShaoXia"
            },
            "tags": [
                   "优化",
                   "python"
            ],
            "date_published": "2016-05-25T23:31:00+08:00",
            "date_modified": "2020-11-20T22:26:17+08:00"
        }
    ]
}
